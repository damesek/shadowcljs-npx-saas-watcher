{
"version":3,
"file":"module$node_modules$vega_dataflow$build$vega_dataflow.js",
"lineCount":51,
"mappings":"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",
"sources":["node_modules/vega-dataflow/build/vega-dataflow.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$vega_dataflow$build$vega_dataflow\"] = function(global,process,require,module,exports,shadow$shims) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-loader')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-loader'], factory) :\n  (global = global || self, factory(global.vega = {}, global.vega, global.vega));\n}(this, function (exports, vegaUtil, vegaLoader) { 'use strict';\n\n  function UniqueList(idFunc) {\n    var $ = idFunc || vegaUtil.identity,\n        list = [],\n        ids = {};\n\n    list.add = function(_) {\n      var id = $(_);\n      if (!ids[id]) {\n        ids[id] = 1;\n        list.push(_);\n      }\n      return list;\n    };\n\n    list.remove = function(_) {\n      var id = $(_), idx;\n      if (ids[id]) {\n        ids[id] = 0;\n        if ((idx = list.indexOf(_)) >= 0) {\n          list.splice(idx, 1);\n        }\n      }\n      return list;\n    };\n\n    return list;\n  }\n\n  /**\n   * Invoke and await a potentially async callback function. If\n   * an error occurs, trap it and route to Dataflow.error.\n   * @param {Dataflow} df - The dataflow instance\n   * @param {function} callback - A callback function to invoke\n   *   and then await. The dataflow will be passed as the single\n   *   argument to the function.\n   */\n  async function asyncCallback(df, callback) {\n    try { await callback(df); } catch (err) { df.error(err); }\n  }\n\n  var TUPLE_ID_KEY = Symbol('vega_id'),\n      TUPLE_ID = 1;\n\n  /**\n   * Checks if an input value is a registered tuple.\n   * @param {*} t - The value to check.\n   * @return {boolean} True if the input is a tuple, false otherwise.\n   */\n  function isTuple(t) {\n    return !!(t && tupleid(t));\n  }\n\n  /**\n   * Returns the id of a tuple.\n   * @param {object} t - The input tuple.\n   * @return {*} the tuple id.\n   */\n  function tupleid(t) {\n    return t[TUPLE_ID_KEY];\n  }\n\n  /**\n   * Sets the id of a tuple.\n   * @param {object} t - The input tuple.\n   * @param {*} id - The id value to set.\n   * @return {object} the input tuple.\n   */\n  function setid(t, id) {\n    t[TUPLE_ID_KEY] = id;\n    return t;\n  }\n\n  /**\n   * Ingest an object or value as a data tuple.\n   * If the input value is an object, an id field will be added to it. For\n   * efficiency, the input object is modified directly. A copy is not made.\n   * If the input value is a literal, it will be wrapped in a new object\n   * instance, with the value accessible as the 'data' property.\n   * @param datum - The value to ingest.\n   * @return {object} The ingested data tuple.\n   */\n  function ingest(datum) {\n    var t = (datum === Object(datum)) ? datum : {data: datum};\n    return tupleid(t) ? t : setid(t, TUPLE_ID++);\n  }\n\n  /**\n   * Given a source tuple, return a derived copy.\n   * @param {object} t - The source tuple.\n   * @return {object} The derived tuple.\n   */\n  function derive(t) {\n    return rederive(t, ingest({}));\n  }\n\n  /**\n   * Rederive a derived tuple by copying values from the source tuple.\n   * @param {object} t - The source tuple.\n   * @param {object} d - The derived tuple.\n   * @return {object} The derived tuple.\n   */\n  function rederive(t, d) {\n    for (var k in t) d[k] = t[k];\n    return d;\n  }\n\n  /**\n   * Replace an existing tuple with a new tuple.\n   * @param {object} t - The existing data tuple.\n   * @param {object} d - The new tuple that replaces the old.\n   * @return {object} The new tuple.\n   */\n  function replace(t, d) {\n    return setid(d, tupleid(t));\n  }\n\n  /**\n   * Generate an augmented comparator function that provides stable\n   * sorting by tuple id when the given comparator produces ties.\n   * @param {function} cmp - The comparator to augment.\n   * @param {function} [f] - Optional tuple accessor function.\n   * @return {function} An augmented comparator function.\n   */\n  function stableCompare(cmp, f) {\n    return !cmp ? null\n      : f ? (a, b) => cmp(a, b) || (tupleid(f(a)) - tupleid(f(b)))\n      : (a, b) => cmp(a, b) || (tupleid(a) - tupleid(b));\n  }\n\n  function isChangeSet(v) {\n    return v && v.constructor === changeset;\n  }\n\n  function changeset() {\n    var add = [],  // insert tuples\n        rem = [],  // remove tuples\n        mod = [],  // modify tuples\n        remp = [], // remove by predicate\n        modp = [], // modify by predicate\n        reflow = false;\n\n    return {\n      constructor: changeset,\n      insert: function(t) {\n        var d = vegaUtil.array(t), i = 0, n = d.length;\n        for (; i<n; ++i) add.push(d[i]);\n        return this;\n      },\n      remove: function(t) {\n        var a = vegaUtil.isFunction(t) ? remp : rem,\n            d = vegaUtil.array(t), i = 0, n = d.length;\n        for (; i<n; ++i) a.push(d[i]);\n        return this;\n      },\n      modify: function(t, field, value) {\n        var m = {field: field, value: vegaUtil.constant(value)};\n        if (vegaUtil.isFunction(t)) {\n          m.filter = t;\n          modp.push(m);\n        } else {\n          m.tuple = t;\n          mod.push(m);\n        }\n        return this;\n      },\n      encode: function(t, set) {\n        if (vegaUtil.isFunction(t)) modp.push({filter: t, field: set});\n        else mod.push({tuple: t, field: set});\n        return this;\n      },\n      reflow: function() {\n        reflow = true;\n        return this;\n      },\n      pulse: function(pulse, tuples) {\n        var cur = {}, out = {}, i, n, m, f, t, id;\n\n        // build lookup table of current tuples\n        for (i=0, n=tuples.length; i<n; ++i) {\n          cur[tupleid(tuples[i])] = 1;\n        }\n\n        // process individual tuples to remove\n        for (i=0, n=rem.length; i<n; ++i) {\n          t = rem[i];\n          cur[tupleid(t)] = -1;\n        }\n\n        // process predicate-based removals\n        for (i=0, n=remp.length; i<n; ++i) {\n          f = remp[i];\n          tuples.forEach(function(t) {\n            if (f(t)) cur[tupleid(t)] = -1;\n          });\n        }\n\n        // process all add tuples\n        for (i=0, n=add.length; i<n; ++i) {\n          t = add[i];\n          id = tupleid(t);\n          if (cur[id]) {\n            // tuple already resides in dataset\n            // if flagged for both add and remove, cancel\n            cur[id] = 1;\n          } else {\n            // tuple does not reside in dataset, add\n            pulse.add.push(ingest(add[i]));\n          }\n        }\n\n        // populate pulse rem list\n        for (i=0, n=tuples.length; i<n; ++i) {\n          t = tuples[i];\n          if (cur[tupleid(t)] < 0) pulse.rem.push(t);\n        }\n\n        // modify helper method\n        function modify(t, f, v) {\n          if (v) {\n            t[f] = v(t);\n          } else {\n            pulse.encode = f;\n          }\n          if (!reflow) out[tupleid(t)] = t;\n        }\n\n        // process individual tuples to modify\n        for (i=0, n=mod.length; i<n; ++i) {\n          m = mod[i];\n          t = m.tuple;\n          f = m.field;\n          id = cur[tupleid(t)];\n          if (id > 0) {\n            modify(t, f, m.value);\n            pulse.modifies(f);\n          }\n        }\n\n        // process predicate-based modifications\n        for (i=0, n=modp.length; i<n; ++i) {\n          m = modp[i];\n          f = m.filter;\n          tuples.forEach(function(t) {\n            if (f(t) && cur[tupleid(t)] > 0) {\n              modify(t, m.field, m.value);\n            }\n          });\n          pulse.modifies(m.field);\n        }\n\n        // upon reflow request, populate mod with all non-removed tuples\n        // otherwise, populate mod with modified tuples only\n        if (reflow) {\n          pulse.mod = rem.length || remp.length\n            ? tuples.filter(function(t) { return cur[tupleid(t)] > 0; })\n            : tuples.slice();\n        } else {\n          for (id in out) pulse.mod.push(out[id]);\n        }\n\n        return pulse;\n      }\n    };\n  }\n\n  var CACHE = '_:mod:_';\n\n  /**\n   * Hash that tracks modifications to assigned values.\n   * Callers *must* use the set method to update values.\n   */\n  function Parameters() {\n    Object.defineProperty(this, CACHE, {writable: true, value: {}});\n  }\n\n  var prototype = Parameters.prototype;\n\n  /**\n   * Set a parameter value. If the parameter value changes, the parameter\n   * will be recorded as modified.\n   * @param {string} name - The parameter name.\n   * @param {number} index - The index into an array-value parameter. Ignored if\n   *   the argument is undefined, null or less than zero.\n   * @param {*} value - The parameter value to set.\n   * @param {boolean} [force=false] - If true, records the parameter as modified\n   *   even if the value is unchanged.\n   * @return {Parameters} - This parameter object.\n   */\n  prototype.set = function(name, index, value, force) {\n    var o = this,\n        v = o[name],\n        mod = o[CACHE];\n\n    if (index != null && index >= 0) {\n      if (v[index] !== value || force) {\n        v[index] = value;\n        mod[index + ':' + name] = -1;\n        mod[name] = -1;\n      }\n    } else if (v !== value || force) {\n      o[name] = value;\n      mod[name] = vegaUtil.isArray(value) ? 1 + value.length : -1;\n    }\n\n    return o;\n  };\n\n  /**\n   * Tests if one or more parameters has been modified. If invoked with no\n   * arguments, returns true if any parameter value has changed. If the first\n   * argument is array, returns trues if any parameter name in the array has\n   * changed. Otherwise, tests if the given name and optional array index has\n   * changed.\n   * @param {string} name - The parameter name to test.\n   * @param {number} [index=undefined] - The parameter array index to test.\n   * @return {boolean} - Returns true if a queried parameter was modified.\n   */\n  prototype.modified = function(name, index) {\n    var mod = this[CACHE], k;\n    if (!arguments.length) {\n      for (k in mod) { if (mod[k]) return true; }\n      return false;\n    } else if (vegaUtil.isArray(name)) {\n      for (k=0; k<name.length; ++k) {\n        if (mod[name[k]]) return true;\n      }\n      return false;\n    }\n    return (index != null && index >= 0)\n      ? (index + 1 < mod[name] || !!mod[index + ':' + name])\n      : !!mod[name];\n  };\n\n  /**\n   * Clears the modification records. After calling this method,\n   * all parameters are considered unmodified.\n   */\n  prototype.clear = function() {\n    this[CACHE] = {};\n    return this;\n  };\n\n  var OP_ID = 0;\n  var PULSE = 'pulse';\n  var NO_PARAMS = new Parameters();\n\n  // Boolean Flags\n  var SKIP     = 1,\n      MODIFIED = 2;\n\n  /**\n   * An Operator is a processing node in a dataflow graph.\n   * Each operator stores a value and an optional value update function.\n   * Operators can accept a hash of named parameters. Parameter values can\n   * either be direct (JavaScript literals, arrays, objects) or indirect\n   * (other operators whose values will be pulled dynamically). Operators\n   * included as parameters will have this operator added as a dependency.\n   * @constructor\n   * @param {*} [init] - The initial value for this operator.\n   * @param {function(object, Pulse)} [update] - An update function. Upon\n   *   evaluation of this operator, the update function will be invoked and the\n   *   return value will be used as the new value of this operator.\n   * @param {object} [params] - The parameters for this operator.\n   * @param {boolean} [react=true] - Flag indicating if this operator should\n   *   listen for changes to upstream operators included as parameters.\n   * @see parameters\n   */\n  function Operator(init, update, params, react) {\n    this.id = ++OP_ID;\n    this.value = init;\n    this.stamp = -1;\n    this.rank = -1;\n    this.qrank = -1;\n    this.flags = 0;\n\n    if (update) {\n      this._update = update;\n    }\n    if (params) this.parameters(params, react);\n  }\n\n  var prototype$1 = Operator.prototype;\n\n  /**\n   * Returns a list of target operators dependent on this operator.\n   * If this list does not exist, it is created and then returned.\n   * @return {UniqueList}\n   */\n  prototype$1.targets = function() {\n    return this._targets || (this._targets = UniqueList(vegaUtil.id));\n  };\n\n  /**\n   * Sets the value of this operator.\n   * @param {*} value - the value to set.\n   * @return {Number} Returns 1 if the operator value has changed\n   *   according to strict equality, returns 0 otherwise.\n   */\n  prototype$1.set = function(value) {\n    if (this.value !== value) {\n      this.value = value;\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  function flag(bit) {\n    return function(state) {\n      var f = this.flags;\n      if (arguments.length === 0) return !!(f & bit);\n      this.flags = state ? (f | bit) : (f & ~bit);\n      return this;\n    };\n  }\n\n  /**\n   * Indicates that operator evaluation should be skipped on the next pulse.\n   * This operator will still propagate incoming pulses, but its update function\n   * will not be invoked. The skip flag is reset after every pulse, so calling\n   * this method will affect processing of the next pulse only.\n   */\n  prototype$1.skip = flag(SKIP);\n\n  /**\n   * Indicates that this operator's value has been modified on its most recent\n   * pulse. Normally modification is checked via strict equality; however, in\n   * some cases it is more efficient to update the internal state of an object.\n   * In those cases, the modified flag can be used to trigger propagation. Once\n   * set, the modification flag persists across pulses until unset. The flag can\n   * be used with the last timestamp to test if a modification is recent.\n   */\n  prototype$1.modified = flag(MODIFIED);\n\n  /**\n   * Sets the parameters for this operator. The parameter values are analyzed for\n   * operator instances. If found, this operator will be added as a dependency\n   * of the parameterizing operator. Operator values are dynamically marshalled\n   * from each operator parameter prior to evaluation. If a parameter value is\n   * an array, the array will also be searched for Operator instances. However,\n   * the search does not recurse into sub-arrays or object properties.\n   * @param {object} params - A hash of operator parameters.\n   * @param {boolean} [react=true] - A flag indicating if this operator should\n   *   automatically update (react) when parameter values change. In other words,\n   *   this flag determines if the operator registers itself as a listener on\n   *   any upstream operators included in the parameters.\n   * @param {boolean} [initonly=false] - A flag indicating if this operator\n   *   should calculate an update only upon its initiatal evaluation, then\n   *   deregister dependencies and suppress all future update invocations.\n   * @return {Operator[]} - An array of upstream dependencies.\n   */\n  prototype$1.parameters = function(params, react, initonly) {\n    react = react !== false;\n    var self = this,\n        argval = (self._argval = self._argval || new Parameters()),\n        argops = (self._argops = self._argops || []),\n        deps = [],\n        name, value, n, i;\n\n    function add(name, index, value) {\n      if (value instanceof Operator) {\n        if (value !== self) {\n          if (react) value.targets().add(self);\n          deps.push(value);\n        }\n        argops.push({op:value, name:name, index:index});\n      } else {\n        argval.set(name, index, value);\n      }\n    }\n\n    for (name in params) {\n      value = params[name];\n\n      if (name === PULSE) {\n        vegaUtil.array(value).forEach(function(op) {\n          if (!(op instanceof Operator)) {\n            vegaUtil.error('Pulse parameters must be operator instances.');\n          } else if (op !== self) {\n            op.targets().add(self);\n            deps.push(op);\n          }\n        });\n        self.source = value;\n      } else if (vegaUtil.isArray(value)) {\n        argval.set(name, -1, Array(n = value.length));\n        for (i=0; i<n; ++i) add(name, i, value[i]);\n      } else {\n        add(name, -1, value);\n      }\n    }\n\n    this.marshall().clear(); // initialize values\n    if (initonly) argops.initonly = true;\n\n    return deps;\n  };\n\n  /**\n   * Internal method for marshalling parameter values.\n   * Visits each operator dependency to pull the latest value.\n   * @return {Parameters} A Parameters object to pass to the update function.\n   */\n  prototype$1.marshall = function(stamp) {\n    var argval = this._argval || NO_PARAMS,\n        argops = this._argops, item, i, n, op, mod;\n\n    if (argops) {\n      for (i=0, n=argops.length; i<n; ++i) {\n        item = argops[i];\n        op = item.op;\n        mod = op.modified() && op.stamp === stamp;\n        argval.set(item.name, item.index, op.value, mod);\n      }\n\n      if (argops.initonly) {\n        for (i=0; i<n; ++i) {\n          item = argops[i];\n          item.op.targets().remove(this);\n        }\n        this._argops = null;\n        this._update = null;\n      }\n    }\n    return argval;\n  };\n\n  /**\n   * Delegate method to perform operator processing.\n   * Subclasses can override this method to perform custom processing.\n   * By default, it marshalls parameters and calls the update function\n   * if that function is defined. If the update function does not\n   * change the operator value then StopPropagation is returned.\n   * If no update function is defined, this method does nothing.\n   * @param {Pulse} pulse - the current dataflow pulse.\n   * @return The output pulse or StopPropagation. A falsy return value\n   *   (including undefined) will let the input pulse pass through.\n   */\n  prototype$1.evaluate = function(pulse) {\n    var update = this._update;\n    if (update) {\n      var params = this.marshall(pulse.stamp),\n          v = update.call(this, params, pulse);\n\n      params.clear();\n      if (v !== this.value) {\n        this.value = v;\n      } else if (!this.modified()) {\n        return pulse.StopPropagation;\n      }\n    }\n  };\n\n  /**\n   * Run this operator for the current pulse. If this operator has already\n   * been run at (or after) the pulse timestamp, returns StopPropagation.\n   * Internally, this method calls {@link evaluate} to perform processing.\n   * If {@link evaluate} returns a falsy value, the input pulse is returned.\n   * This method should NOT be overridden, instead overrride {@link evaluate}.\n   * @param {Pulse} pulse - the current dataflow pulse.\n   * @return the output pulse for this operator (or StopPropagation)\n   */\n  prototype$1.run = function(pulse) {\n    if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n    var rv;\n    if (this.skip()) {\n      this.skip(false);\n      rv = 0;\n    } else {\n      rv = this.evaluate(pulse);\n    }\n    return (this.pulse = rv || pulse);\n  };\n\n  /**\n   * Add an operator to the dataflow graph. This function accepts a\n   * variety of input argument types. The basic signature supports an\n   * initial value, update function and parameters. If the first parameter\n   * is an Operator instance, it will be added directly. If it is a\n   * constructor for an Operator subclass, a new instance will be instantiated.\n   * Otherwise, if the first parameter is a function instance, it will be used\n   * as the update function and a null initial value is assumed.\n   * @param {*} init - One of: the operator to add, the initial value of\n   *   the operator, an operator class to instantiate, or an update function.\n   * @param {function} [update] - The operator update function.\n   * @param {object} [params] - The operator parameters.\n   * @param {boolean} [react=true] - Flag indicating if this operator should\n   *   listen for changes to upstream operators included as parameters.\n   * @return {Operator} - The added operator.\n   */\n  function add(init, update, params, react) {\n    var shift = 1,\n      op;\n\n    if (init instanceof Operator) {\n      op = init;\n    } else if (init && init.prototype instanceof Operator) {\n      op = new init();\n    } else if (vegaUtil.isFunction(init)) {\n      op = new Operator(null, init);\n    } else {\n      shift = 0;\n      op = new Operator(init, update);\n    }\n\n    this.rank(op);\n    if (shift) {\n      react = params;\n      params = update;\n    }\n    if (params) this.connect(op, op.parameters(params, react));\n    this.touch(op);\n\n    return op;\n  }\n\n  /**\n   * Connect a target operator as a dependent of source operators.\n   * If necessary, this method will rerank the target operator and its\n   * dependents to ensure propagation proceeds in a topologically sorted order.\n   * @param {Operator} target - The target operator.\n   * @param {Array<Operator>} - The source operators that should propagate\n   *   to the target operator.\n   */\n  function connect(target, sources) {\n    var targetRank = target.rank, i, n;\n\n    for (i=0, n=sources.length; i<n; ++i) {\n      if (targetRank < sources[i].rank) {\n        this.rerank(target);\n        return;\n      }\n    }\n  }\n\n  var STREAM_ID = 0;\n\n  /**\n   * Models an event stream.\n   * @constructor\n   * @param {function(Object, number): boolean} [filter] - Filter predicate.\n   *   Events pass through when truthy, events are suppressed when falsy.\n   * @param {function(Object): *} [apply] - Applied to input events to produce\n   *   new event values.\n   * @param {function(Object)} [receive] - Event callback function to invoke\n   *   upon receipt of a new event. Use to override standard event processing.\n   */\n  function EventStream(filter, apply, receive) {\n    this.id = ++STREAM_ID;\n    this.value = null;\n    if (receive) this.receive = receive;\n    if (filter) this._filter = filter;\n    if (apply) this._apply = apply;\n  }\n\n  /**\n   * Creates a new event stream instance with the provided\n   * (optional) filter, apply and receive functions.\n   * @param {function(Object, number): boolean} [filter] - Filter predicate.\n   *   Events pass through when truthy, events are suppressed when falsy.\n   * @param {function(Object): *} [apply] - Applied to input events to produce\n   *   new event values.\n   * @see EventStream\n   */\n  function stream(filter, apply, receive) {\n    return new EventStream(filter, apply, receive);\n  }\n\n  var prototype$2 = EventStream.prototype;\n\n  prototype$2._filter = vegaUtil.truthy;\n\n  prototype$2._apply = vegaUtil.identity;\n\n  prototype$2.targets = function() {\n    return this._targets || (this._targets = UniqueList(vegaUtil.id));\n  };\n\n  prototype$2.consume = function(_) {\n    if (!arguments.length) return !!this._consume;\n    this._consume = !!_;\n    return this;\n  };\n\n  prototype$2.receive = function(evt) {\n    if (this._filter(evt)) {\n      var val = (this.value = this._apply(evt)),\n          trg = this._targets,\n          n = trg ? trg.length : 0,\n          i = 0;\n\n      for (; i<n; ++i) trg[i].receive(val);\n\n      if (this._consume) {\n        evt.preventDefault();\n        evt.stopPropagation();\n      }\n    }\n  };\n\n  prototype$2.filter = function(filter) {\n    var s = stream(filter);\n    this.targets().add(s);\n    return s;\n  };\n\n  prototype$2.apply = function(apply) {\n    var s = stream(null, apply);\n    this.targets().add(s);\n    return s;\n  };\n\n  prototype$2.merge = function() {\n    var s = stream();\n\n    this.targets().add(s);\n    for (var i=0, n=arguments.length; i<n; ++i) {\n      arguments[i].targets().add(s);\n    }\n\n    return s;\n  };\n\n  prototype$2.throttle = function(pause) {\n    var t = -1;\n    return this.filter(function() {\n      var now = Date.now();\n      if ((now - t) > pause) {\n        t = now;\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n  };\n\n  prototype$2.debounce = function(delay) {\n    var s = stream();\n\n    this.targets().add(stream(null, null,\n      vegaUtil.debounce(delay, function(e) {\n        var df = e.dataflow;\n        s.receive(e);\n        if (df && df.run) df.run();\n      })\n    ));\n\n    return s;\n  };\n\n  prototype$2.between = function(a, b) {\n    var active = false;\n    a.targets().add(stream(null, null, function() { active = true; }));\n    b.targets().add(stream(null, null, function() { active = false; }));\n    return this.filter(function() { return active; });\n  };\n\n  /**\n   * Create a new event stream from an event source.\n   * @param {object} source - The event source to monitor. The input must\n   *  support the addEventListener method.\n   * @param {string} type - The event type.\n   * @param {function(object): boolean} [filter] - Event filter function.\n   * @param {function(object): *} [apply] - Event application function.\n   *   If provided, this function will be invoked and the result will be\n   *   used as the downstream event value.\n   * @return {EventStream}\n   */\n  function events(source, type, filter, apply) {\n    var df = this,\n        s = stream(filter, apply),\n        send = function(e) {\n          e.dataflow = df;\n          try {\n            s.receive(e);\n          } catch (error) {\n            df.error(error);\n          } finally {\n            df.run();\n          }\n        },\n        sources;\n\n    if (typeof source === 'string' && typeof document !== 'undefined') {\n      sources = document.querySelectorAll(source);\n    } else {\n      sources = vegaUtil.array(source);\n    }\n\n    for (var i=0, n=sources.length; i<n; ++i) {\n      sources[i].addEventListener(type, send);\n    }\n\n    return s;\n  }\n\n  const parse = vegaLoader.read;\n\n  /**\n   * Ingests new data into the dataflow. First parses the data using the\n   * vega-loader read method, then pulses a changeset to the target operator.\n   * @param {Operator} target - The Operator to target with ingested data,\n   *   typically a Collect transform instance.\n   * @param {*} data - The input data, prior to parsing. For JSON this may\n   *   be a string or an object. For CSV, TSV, etc should be a string.\n   * @param {object} format - The data format description for parsing\n   *   loaded data. This object is passed to the vega-loader read method.\n   * @returns {Dataflow}\n   */\n  function ingest$1(target, data, format) {\n    return this.pulse(target, this.changeset().insert(parse(data, format)));\n  }\n\n  /**\n   * Request data from an external source, parse it, and return a Promise.\n   * @param {string} url - The URL from which to load the data. This string\n   *   is passed to the vega-loader load method.\n   * @param {object} [format] - The data format description for parsing\n   *   loaded data. This object is passed to the vega-loader read method.\n   * @return {Promise} A Promise that resolves upon completion of the request.\n   *   The resolved object contains the following properties:\n   *   - data: an array of parsed data (or null upon error)\n   *   - status: a code for success (0), load fail (-1), or parse fail (-2)\n   */\n  async function request(url, format) {\n    const df = this;\n    let status = 0, data;\n\n    try {\n      data = await df.loader().load(url, {\n        context: 'dataflow',\n        response: vegaLoader.responseType(format && format.type)\n      });\n      try {\n        data = parse(data, format);\n      } catch (err) {\n        status = -2;\n        df.warn('Data ingestion failed', url, err);\n      }\n    } catch (err) {\n      status = -1;\n      df.warn('Loading failed', url, err);\n    }\n\n    return {data, status};\n  }\n\n  async function preload(target, url, format) {\n    const df = this,\n          pending = df._pending || loadPending(df);\n\n    pending.requests += 1;\n\n    const res = await df.request(url, format);\n    df.pulse(target, df.changeset().remove(vegaUtil.truthy).insert(res.data || []));\n\n    pending.done();\n    return res;\n  }\n\n  function loadPending(df) {\n    var pending = new Promise(function(a) { accept = a; }),\n        accept;\n\n    pending.requests = 0;\n\n    pending.done = function() {\n      if (--pending.requests === 0) {\n        df._pending = null;\n        accept(df);\n      }\n    };\n\n    return (df._pending = pending);\n  }\n\n  var SKIP$1 = {skip: true};\n\n  /**\n   * Perform operator updates in response to events. Applies an\n   * update function to compute a new operator value. If the update function\n   * returns a {@link ChangeSet}, the operator will be pulsed with those tuple\n   * changes. Otherwise, the operator value will be updated to the return value.\n   * @param {EventStream|Operator} source - The event source to react to.\n   *   This argument can be either an EventStream or an Operator.\n   * @param {Operator|function(object):Operator} target - The operator to update.\n   *   This argument can either be an Operator instance or (if the source\n   *   argument is an EventStream), a function that accepts an event object as\n   *   input and returns an Operator to target.\n   * @param {function(Parameters,Event): *} [update] - Optional update function\n   *   to compute the new operator value, or a literal value to set. Update\n   *   functions expect to receive a parameter object and event as arguments.\n   *   This function can either return a new operator value or (if the source\n   *   argument is an EventStream) a {@link ChangeSet} instance to pulse\n   *   the target operator with tuple changes.\n   * @param {object} [params] - The update function parameters.\n   * @param {object} [options] - Additional options hash. If not overridden,\n   *   updated operators will be skipped by default.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *  be skipped: it will not be evaluated, but its dependents will be.\n   * @param {boolean} [options.force] - If true, the operator will\n   *   be re-evaluated even if its value has not changed.\n   * @return {Dataflow}\n   */\n  function on(source, target, update, params, options) {\n    var fn = source instanceof Operator ? onOperator : onStream;\n    fn(this, source, target, update, params, options);\n    return this;\n  }\n\n  function onStream(df, stream, target, update, params, options) {\n    var opt = vegaUtil.extend({}, options, SKIP$1), func, op;\n\n    if (!vegaUtil.isFunction(target)) target = vegaUtil.constant(target);\n\n    if (update === undefined) {\n      func = e => df.touch(target(e));\n    } else if (vegaUtil.isFunction(update)) {\n      op = new Operator(null, update, params, false);\n      func = e => {\n        op.evaluate(e);\n        const t = target(e), v = op.value;\n        isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);\n      };\n    } else {\n      func = e => df.update(target(e), update, opt);\n    }\n\n    stream.apply(func);\n  }\n\n  function onOperator(df, source, target, update, params, options) {\n    if (update === undefined) {\n      source.targets().add(target);\n    } else {\n      const opt = options || {},\n            op = new Operator(null, updater(target, update), params, false);\n      op.modified(opt.force);\n      op.rank = source.rank;       // immediately follow source\n      source.targets().add(op);    // add dependency\n\n      if (target) {\n        op.skip(true);             // skip first invocation\n        op.value = target.value;   // initialize value\n        op.targets().add(target);  // chain dependencies\n        df.connect(target, [op]);  // rerank as needed, #1672\n      }\n    }\n  }\n\n  function updater(target, update) {\n    update = vegaUtil.isFunction(update) ? update : vegaUtil.constant(update);\n    return target\n      ? function(_, pulse) {\n          const value = update(_, pulse);\n          if (!target.skip()) {\n            target.skip(value !== this.value).value = value;\n          }\n          return value;\n        }\n      : update;\n  }\n\n  /**\n   * Assigns a rank to an operator. Ranks are assigned in increasing order\n   * by incrementing an internal rank counter.\n   * @param {Operator} op - The operator to assign a rank.\n   */\n  function rank(op) {\n    op.rank = ++this._rank;\n  }\n\n  /**\n   * Re-ranks an operator and all downstream target dependencies. This\n   * is necessary when upstream dependencies of higher rank are added to\n   * a target operator.\n   * @param {Operator} op - The operator to re-rank.\n   */\n  function rerank(op) {\n    var queue = [op],\n        cur, list, i;\n\n    while (queue.length) {\n      this.rank(cur = queue.pop());\n      if (list = cur._targets) {\n        for (i=list.length; --i >= 0;) {\n          queue.push(cur = list[i]);\n          if (cur === op) vegaUtil.error('Cycle detected in dataflow graph.');\n        }\n      }\n    }\n  }\n\n  /**\n   * Sentinel value indicating pulse propagation should stop.\n   */\n  var StopPropagation = {};\n\n  // Pulse visit type flags\n  var ADD       = (1 << 0),\n      REM       = (1 << 1),\n      MOD       = (1 << 2),\n      ADD_REM   = ADD | REM,\n      ADD_MOD   = ADD | MOD,\n      ALL       = ADD | REM | MOD,\n      REFLOW    = (1 << 3),\n      SOURCE    = (1 << 4),\n      NO_SOURCE = (1 << 5),\n      NO_FIELDS = (1 << 6);\n\n  /**\n   * A Pulse enables inter-operator communication during a run of the\n   * dataflow graph. In addition to the current timestamp, a pulse may also\n   * contain a change-set of added, removed or modified data tuples, as well as\n   * a pointer to a full backing data source. Tuple change sets may not\n   * be fully materialized; for example, to prevent needless array creation\n   * a change set may include larger arrays and corresponding filter functions.\n   * The pulse provides a {@link visit} method to enable proper and efficient\n   * iteration over requested data tuples.\n   *\n   * In addition, each pulse can track modification flags for data tuple fields.\n   * Responsible transform operators should call the {@link modifies} method to\n   * indicate changes to data fields. The {@link modified} method enables\n   * querying of this modification state.\n   *\n   * @constructor\n   * @param {Dataflow} dataflow - The backing dataflow instance.\n   * @param {number} stamp - The current propagation timestamp.\n   * @param {string} [encode] - An optional encoding set name, which is then\n   *   accessible as Pulse.encode. Operators can respond to (or ignore) this\n   *   setting as appropriate. This parameter can be used in conjunction with\n   *   the Encode transform in the vega-encode module.\n   */\n  function Pulse(dataflow, stamp, encode) {\n    this.dataflow = dataflow;\n    this.stamp = stamp == null ? -1 : stamp;\n    this.add = [];\n    this.rem = [];\n    this.mod = [];\n    this.fields = null;\n    this.encode = encode || null;\n  }\n\n  var prototype$3 = Pulse.prototype;\n\n  /**\n   * Sentinel value indicating pulse propagation should stop.\n   */\n  prototype$3.StopPropagation = StopPropagation;\n\n  /**\n   * Boolean flag indicating ADD (added) tuples.\n   */\n  prototype$3.ADD = ADD;\n\n  /**\n   * Boolean flag indicating REM (removed) tuples.\n   */\n  prototype$3.REM = REM;\n\n  /**\n   * Boolean flag indicating MOD (modified) tuples.\n   */\n  prototype$3.MOD = MOD;\n\n  /**\n   * Boolean flag indicating ADD (added) and REM (removed) tuples.\n   */\n  prototype$3.ADD_REM = ADD_REM;\n\n  /**\n   * Boolean flag indicating ADD (added) and MOD (modified) tuples.\n   */\n  prototype$3.ADD_MOD = ADD_MOD;\n\n  /**\n   * Boolean flag indicating ADD, REM and MOD tuples.\n   */\n  prototype$3.ALL = ALL;\n\n  /**\n   * Boolean flag indicating all tuples in a data source\n   * except for the ADD, REM and MOD tuples.\n   */\n  prototype$3.REFLOW = REFLOW;\n\n  /**\n   * Boolean flag indicating a 'pass-through' to a\n   * backing data source, ignoring ADD, REM and MOD tuples.\n   */\n  prototype$3.SOURCE = SOURCE;\n\n  /**\n   * Boolean flag indicating that source data should be\n   * suppressed when creating a forked pulse.\n   */\n  prototype$3.NO_SOURCE = NO_SOURCE;\n\n  /**\n   * Boolean flag indicating that field modifications should be\n   * suppressed when creating a forked pulse.\n   */\n  prototype$3.NO_FIELDS = NO_FIELDS;\n\n  /**\n   * Creates a new pulse based on the values of this pulse.\n   * The dataflow, time stamp and field modification values are copied over.\n   * By default, new empty ADD, REM and MOD arrays are created.\n   * @param {number} flags - Integer of boolean flags indicating which (if any)\n   *   tuple arrays should be copied to the new pulse. The supported flag values\n   *   are ADD, REM and MOD. Array references are copied directly: new array\n   *   instances are not created.\n   * @return {Pulse} - The forked pulse instance.\n   * @see init\n   */\n  prototype$3.fork = function(flags) {\n    return new Pulse(this.dataflow).init(this, flags);\n  };\n\n  /**\n   * Creates a copy of this pulse with new materialized array\n   * instances for the ADD, REM, MOD, and SOURCE arrays.\n   * The dataflow, time stamp and field modification values are copied over.\n   * @return {Pulse} - The cloned pulse instance.\n   * @see init\n   */\n  prototype$3.clone = function() {\n    var p = this.fork(ALL);\n    p.add = p.add.slice();\n    p.rem = p.rem.slice();\n    p.mod = p.mod.slice();\n    if (p.source) p.source = p.source.slice();\n    return p.materialize(ALL | SOURCE);\n  };\n\n  /**\n   * Returns a pulse that adds all tuples from a backing source. This is\n   * useful for cases where operators are added to a dataflow after an\n   * upstream data pipeline has already been processed, ensuring that\n   * new operators can observe all tuples within a stream.\n   * @return {Pulse} - A pulse instance with all source tuples included\n   *   in the add array. If the current pulse already has all source\n   *   tuples in its add array, it is returned directly. If the current\n   *   pulse does not have a backing source, it is returned directly.\n   */\n  prototype$3.addAll = function() {\n    var p = this;\n    if (!this.source || this.source.length === this.add.length) {\n      return p;\n    } else {\n      p = new Pulse(this.dataflow).init(this);\n      p.add = p.source;\n      return p;\n    }\n  };\n\n  /**\n   * Initialize this pulse based on the values of another pulse. This method\n   * is used internally by {@link fork} to initialize a new forked tuple.\n   * The dataflow, time stamp and field modification values are copied over.\n   * By default, new empty ADD, REM and MOD arrays are created.\n   * @param {Pulse} src - The source pulse to copy from.\n   * @param {number} flags - Integer of boolean flags indicating which (if any)\n   *   tuple arrays should be copied to the new pulse. The supported flag values\n   *   are ADD, REM and MOD. Array references are copied directly: new array\n   *   instances are not created. By default, source data arrays are copied\n   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.\n   * @return {Pulse} - Returns this Pulse instance.\n   */\n  prototype$3.init = function(src, flags) {\n    var p = this;\n    p.stamp = src.stamp;\n    p.encode = src.encode;\n\n    if (src.fields && !(flags & NO_FIELDS)) {\n      p.fields = src.fields;\n    }\n\n    if (flags & ADD) {\n      p.addF = src.addF;\n      p.add = src.add;\n    } else {\n      p.addF = null;\n      p.add = [];\n    }\n\n    if (flags & REM) {\n      p.remF = src.remF;\n      p.rem = src.rem;\n    } else {\n      p.remF = null;\n      p.rem = [];\n    }\n\n    if (flags & MOD) {\n      p.modF = src.modF;\n      p.mod = src.mod;\n    } else {\n      p.modF = null;\n      p.mod = [];\n    }\n\n    if (flags & NO_SOURCE) {\n      p.srcF = null;\n      p.source = null;\n    } else {\n      p.srcF = src.srcF;\n      p.source = src.source;\n    }\n\n    return p;\n  };\n\n  /**\n   * Schedules a function to run after pulse propagation completes.\n   * @param {function} func - The function to run.\n   */\n  prototype$3.runAfter = function(func) {\n    this.dataflow.runAfter(func);\n  };\n\n  /**\n   * Indicates if tuples have been added, removed or modified.\n   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.\n   *   Defaults to ALL, returning true if any tuple type has changed.\n   * @return {boolean} - Returns true if one or more queried tuple types have\n   *   changed, false otherwise.\n   */\n  prototype$3.changed = function(flags) {\n    var f = flags || ALL;\n    return ((f & ADD) && this.add.length)\n        || ((f & REM) && this.rem.length)\n        || ((f & MOD) && this.mod.length);\n  };\n\n  /**\n   * Forces a \"reflow\" of tuple values, such that all tuples in the backing\n   * source are added to the MOD set, unless already present in the ADD set.\n   * @param {boolean} [fork=false] - If true, returns a forked copy of this\n   *   pulse, and invokes reflow on that derived pulse.\n   * @return {Pulse} - The reflowed pulse instance.\n   */\n  prototype$3.reflow = function(fork) {\n    if (fork) return this.fork(ALL).reflow();\n\n    var len = this.add.length,\n        src = this.source && this.source.length;\n    if (src && src !== len) {\n      this.mod = this.source;\n      if (len) this.filter(MOD, filter(this, ADD));\n    }\n    return this;\n  };\n\n  /**\n   * Marks one or more data field names as modified to assist dependency\n   * tracking and incremental processing by transform operators.\n   * @param {string|Array<string>} _ - The field(s) to mark as modified.\n   * @return {Pulse} - This pulse instance.\n   */\n  prototype$3.modifies = function(_) {\n    var hash = this.fields || (this.fields = {});\n    if (vegaUtil.isArray(_)) {\n      _.forEach(f => hash[f] = true);\n    } else {\n      hash[_] = true;\n    }\n    return this;\n  };\n\n  /**\n   * Checks if one or more data fields have been modified during this pulse\n   * propagation timestamp.\n   * @param {string|Array<string>} _ - The field(s) to check for modified.\n   * @param {boolean} nomod - If true, will check the modified flag even if\n   *   no mod tuples exist. If false (default), mod tuples must be present.\n   * @return {boolean} - Returns true if any of the provided fields has been\n   *   marked as modified, false otherwise.\n   */\n  prototype$3.modified = function(_, nomod) {\n    var fields = this.fields;\n    return !((nomod || this.mod.length) && fields) ? false\n      : !arguments.length ? !!fields\n      : vegaUtil.isArray(_) ? _.some(function(f) { return fields[f]; })\n      : fields[_];\n  };\n\n  /**\n   * Adds a filter function to one more tuple sets. Filters are applied to\n   * backing tuple arrays, to determine the actual set of tuples considered\n   * added, removed or modified. They can be used to delay materialization of\n   * a tuple set in order to avoid expensive array copies. In addition, the\n   * filter functions can serve as value transformers: unlike standard predicate\n   * function (which return boolean values), Pulse filters should return the\n   * actual tuple value to process. If a tuple set is already filtered, the\n   * new filter function will be appended into a conjuntive ('and') query.\n   * @param {number} flags - Flags indicating the tuple set(s) to filter.\n   * @param {function(*):object} filter - Filter function that will be applied\n   *   to the tuple set array, and should return a data tuple if the value\n   *   should be included in the tuple set, and falsy (or null) otherwise.\n   * @return {Pulse} - Returns this pulse instance.\n   */\n  prototype$3.filter = function(flags, filter) {\n    var p = this;\n    if (flags & ADD) p.addF = addFilter(p.addF, filter);\n    if (flags & REM) p.remF = addFilter(p.remF, filter);\n    if (flags & MOD) p.modF = addFilter(p.modF, filter);\n    if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);\n    return p;\n  };\n\n  function addFilter(a, b) {\n    return a ? function(t,i) { return a(t,i) && b(t,i); } : b;\n  }\n\n  /**\n   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have\n   * a registered filter function, it will be applied and the tuple set(s) will\n   * be replaced with materialized tuple arrays.\n   * @param {number} flags - Flags indicating the tuple set(s) to materialize.\n   * @return {Pulse} - Returns this pulse instance.\n   */\n  prototype$3.materialize = function(flags) {\n    flags = flags || ALL;\n    var p = this;\n    if ((flags & ADD) && p.addF) {\n      p.add = materialize(p.add, p.addF);\n      p.addF = null;\n    }\n    if ((flags & REM) && p.remF) {\n      p.rem = materialize(p.rem, p.remF);\n      p.remF = null;\n    }\n    if ((flags & MOD) && p.modF) {\n      p.mod = materialize(p.mod, p.modF);\n      p.modF = null;\n    }\n    if ((flags & SOURCE) && p.srcF) {\n      p.source = p.source.filter(p.srcF);\n      p.srcF = null;\n    }\n    return p;\n  };\n\n  function materialize(data, filter) {\n    var out = [];\n    vegaUtil.visitArray(data, filter, function(_) { out.push(_); });\n    return out;\n  }\n\n  function filter(pulse, flags) {\n    var map = {};\n    pulse.visit(flags, function(t) { map[tupleid(t)] = 1; });\n    return function(t) { return map[tupleid(t)] ? null : t; };\n  }\n\n  /**\n   * Visit one or more tuple sets in this pulse.\n   * @param {number} flags - Flags indicating the tuple set(s) to visit.\n   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source\n   *   has been set).\n   * @param {function(object):*} - Visitor function invoked per-tuple.\n   * @return {Pulse} - Returns this pulse instance.\n   */\n  prototype$3.visit = function(flags, visitor) {\n    var p = this, v = visitor, src, sum;\n\n    if (flags & SOURCE) {\n      vegaUtil.visitArray(p.source, p.srcF, v);\n      return p;\n    }\n\n    if (flags & ADD) vegaUtil.visitArray(p.add, p.addF, v);\n    if (flags & REM) vegaUtil.visitArray(p.rem, p.remF, v);\n    if (flags & MOD) vegaUtil.visitArray(p.mod, p.modF, v);\n\n    if ((flags & REFLOW) && (src = p.source)) {\n      sum = p.add.length + p.mod.length;\n      if (sum === src.length) ; else if (sum) {\n        vegaUtil.visitArray(src, filter(p, ADD_MOD), v);\n      } else {\n        // if no add/rem/mod tuples, visit source\n        vegaUtil.visitArray(src, p.srcF, v);\n      }\n    }\n\n    return p;\n  };\n\n  /**\n   * Represents a set of multiple pulses. Used as input for operators\n   * that accept multiple pulses at a time. Contained pulses are\n   * accessible via the public \"pulses\" array property. This pulse doe\n   * not carry added, removed or modified tuples directly. However,\n   * the visit method can be used to traverse all such tuples contained\n   * in sub-pulses with a timestamp matching this parent multi-pulse.\n   * @constructor\n   * @param {Dataflow} dataflow - The backing dataflow instance.\n   * @param {number} stamp - The timestamp.\n   * @param {Array<Pulse>} pulses - The sub-pulses for this multi-pulse.\n   */\n  function MultiPulse(dataflow, stamp, pulses, encode) {\n    var p = this,\n        c = 0,\n        pulse, hash, i, n, f;\n\n    this.dataflow = dataflow;\n    this.stamp = stamp;\n    this.fields = null;\n    this.encode = encode || null;\n    this.pulses = pulses;\n\n    for (i=0, n=pulses.length; i<n; ++i) {\n      pulse = pulses[i];\n      if (pulse.stamp !== stamp) continue;\n\n      if (pulse.fields) {\n        hash = p.fields || (p.fields = {});\n        for (f in pulse.fields) { hash[f] = 1; }\n      }\n\n      if (pulse.changed(p.ADD)) c |= p.ADD;\n      if (pulse.changed(p.REM)) c |= p.REM;\n      if (pulse.changed(p.MOD)) c |= p.MOD;\n    }\n\n    this.changes = c;\n  }\n\n  var prototype$4 = vegaUtil.inherits(MultiPulse, Pulse);\n\n  /**\n   * Creates a new pulse based on the values of this pulse.\n   * The dataflow, time stamp and field modification values are copied over.\n   * @return {Pulse}\n   */\n  prototype$4.fork = function(flags) {\n    var p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);\n    if (flags !== undefined) {\n      if (flags & p.ADD) {\n        this.visit(p.ADD, function(t) { return p.add.push(t); });\n      }\n      if (flags & p.REM) {\n        this.visit(p.REM, function(t) { return p.rem.push(t); });\n      }\n      if (flags & p.MOD) {\n        this.visit(p.MOD, function(t) { return p.mod.push(t); });\n      }\n    }\n    return p;\n  };\n\n  prototype$4.changed = function(flags) {\n    return this.changes & flags;\n  };\n\n  prototype$4.modified = function(_) {\n    var p = this, fields = p.fields;\n    return !(fields && (p.changes & p.MOD)) ? 0\n      : vegaUtil.isArray(_) ? _.some(function(f) { return fields[f]; })\n      : fields[_];\n  };\n\n  prototype$4.filter = function() {\n    vegaUtil.error('MultiPulse does not support filtering.');\n  };\n\n  prototype$4.materialize = function() {\n    vegaUtil.error('MultiPulse does not support materialization.');\n  };\n\n  prototype$4.visit = function(flags, visitor) {\n    var p = this,\n        pulses = p.pulses,\n        n = pulses.length,\n        i = 0;\n\n    if (flags & p.SOURCE) {\n      for (; i<n; ++i) {\n        pulses[i].visit(flags, visitor);\n      }\n    } else {\n      for (; i<n; ++i) {\n        if (pulses[i].stamp === p.stamp) {\n          pulses[i].visit(flags, visitor);\n        }\n      }\n    }\n\n    return p;\n  };\n\n  /* eslint-disable require-atomic-updates */\n\n  /**\n   * Evaluates the dataflow and returns a Promise that resolves when pulse\n   * propagation completes. This method will increment the current timestamp\n   * and process all updated, pulsed and touched operators. When invoked for\n   * the first time, all registered operators will be processed. This method\n   * should not be invoked by third-party clients, use {@link runAsync} or\n   * {@link run} instead.\n   * @param {string} [encode] - The name of an encoding set to invoke during\n   *   propagation. This value is added to generated Pulse instances;\n   *   operators can then respond to (or ignore) this setting as appropriate.\n   *   This parameter can be used in conjunction with the Encode transform in\n   *   the vega-encode package.\n   * @param {function} [prerun] - An optional callback function to invoke\n   *   immediately before dataflow evaluation commences.\n   * @param {function} [postrun] - An optional callback function to invoke\n   *   after dataflow evaluation completes. The callback will be invoked\n   *   after those registered via {@link runAfter}.\n   * @return {Promise} - A promise that resolves to this dataflow after\n   *   evaluation completes.\n   */\n  async function evaluate(encode, prerun, postrun) {\n    const df = this,\n          level = df.logLevel();\n\n    // if the pulse value is set, this is a re-entrant call\n    if (df._pulse) return reentrant(df);\n\n    // wait for pending datasets to load\n    if (df._pending) {\n      await df._pending;\n    }\n\n    // invoke prerun function, if provided\n    if (prerun) await asyncCallback(df, prerun);\n\n    // exit early if there are no updates\n    if (!df._touched.length) {\n      df.info('Dataflow invoked, but nothing to do.');\n      return df;\n    }\n\n    // increment timestamp clock\n    let stamp = ++df._clock,\n        count = 0, op, next, dt, error;\n\n    // set the current pulse\n    df._pulse = new Pulse(df, stamp, encode);\n\n    if (level >= vegaUtil.Info) {\n      dt = Date.now();\n      df.debug('-- START PROPAGATION (' + stamp + ') -----');\n    }\n\n    // initialize priority queue, reset touched operators\n    df._touched.forEach(op => df._enqueue(op, true));\n    df._touched = UniqueList(vegaUtil.id);\n\n    try {\n      while (df._heap.size() > 0) {\n        // dequeue operator with highest priority\n        op = df._heap.pop();\n\n        // re-queue if rank changed\n        if (op.rank !== op.qrank) { df._enqueue(op, true); continue; }\n\n        // otherwise, evaluate the operator\n        next = op.run(df._getPulse(op, encode));\n\n        // await if operator returned a promise\n        if (next.then) {\n          next = await next;\n        }\n\n        if (level >= vegaUtil.Debug) {\n          df.debug(op.id, next === StopPropagation ? 'STOP' : next, op);\n        }\n\n        // propagate evaluation, enqueue dependent operators\n        if (next !== StopPropagation) {\n          if (op._targets) op._targets.forEach(op => df._enqueue(op));\n        }\n\n        // increment visit counter\n        ++count;\n      }\n    } catch (err) {\n      df._heap.clear();\n      error = err;\n    }\n\n    // reset pulse map\n    df._input = {};\n    df._pulse = null;\n\n    if (level >= vegaUtil.Info) {\n      dt = Date.now() - dt;\n      df.info('> Pulse ' + stamp + ': ' + count + ' operators; ' + dt + 'ms');\n    }\n\n    if (error) {\n      df._postrun = [];\n      df.error(error);\n    }\n\n    // invoke callbacks queued via runAfter\n    if (df._postrun.length) {\n      const pr = df._postrun.sort((a, b) => b.priority - a.priority);\n      df._postrun = [];\n      for (let i=0; i<pr.length; ++i) {\n        await asyncCallback(df, pr[i].callback);\n      }\n    }\n\n    // invoke postrun function, if provided\n    if (postrun) await asyncCallback(df, postrun);\n\n    return df;\n  }\n\n  /**\n   * Queues dataflow evaluation to run once any other queued evaluations have\n   * completed and returns a Promise that resolves when the queued pulse\n   * propagation completes. If provided, a callback function will be invoked\n   * immediately before evaluation commences. This method will ensure a\n   * separate evaluation is invoked for each time it is called.\n   * @param {string} [encode] - The name of an encoding set to invoke during\n   *   propagation. This value is added to generated Pulse instances;\n   *   operators can then respond to (or ignore) this setting as appropriate.\n   *   This parameter can be used in conjunction with the Encode transform in\n   *   the vega-encode package.\n   * @param {function} [prerun] - An optional callback function to invoke\n   *   immediately before dataflow evaluation commences.\n   * @param {function} [postrun] - An optional callback function to invoke\n   *   after dataflow evaluation completes. The callback will be invoked\n   *   after those registered via {@link runAfter}.\n   * @return {Promise} - A promise that resolves to this dataflow after\n   *   evaluation completes.\n   */\n  async function runAsync(encode, prerun, postrun) {\n    // await previously queued functions\n    while (this._running) await this._running;\n\n    // run dataflow, manage running promise\n    const clear = () => this._running = null;\n    (this._running = this.evaluate(encode, prerun, postrun))\n      .then(clear, clear);\n\n    return this._running;\n  }\n\n  /**\n   * Requests dataflow evaluation and the immediately returns this dataflow\n   * instance. If there are pending data loading or other asynchronous\n   * operations, the dataflow will evaluate asynchronously after this method\n   * has been invoked. To track when dataflow evaluation completes, use the\n   * {@link runAsync} method instead. This method will raise an error if\n   * invoked while the dataflow is already in the midst of evaluation.\n   * @param {string} [encode] - The name of an encoding set to invoke during\n   *   propagation. This value is added to generated Pulse instances;\n   *   operators can then respond to (or ignore) this setting as appropriate.\n   *   This parameter can be used in conjunction with the Encode transform in\n   *   the vega-encode module.\n   * @param {function} [prerun] - An optional callback function to invoke\n   *   immediately before dataflow evaluation commences.\n   * @param {function} [postrun] - An optional callback function to invoke\n   *   after dataflow evaluation completes. The callback will be invoked\n   *   after those registered via {@link runAfter}.\n   * @return {Dataflow} - This dataflow instance.\n   */\n  function run(encode, prerun, postrun) {\n    return this._pulse ? reentrant(this)\n      : (this.evaluate(encode, prerun, postrun), this);\n  }\n\n  /**\n   * Schedules a callback function to be invoked after the current pulse\n   * propagation completes. If no propagation is currently occurring,\n   * the function is invoked immediately. Callbacks scheduled via runAfter\n   * are invoked immediately upon completion of the current cycle, before\n   * any request queued via runAsync. This method is primarily intended for\n   * internal use. Third-party callers using runAfter to schedule a callback\n   * that invokes {@link run} or {@link runAsync} should not use this method,\n   * but instead use {@link runAsync} with prerun or postrun arguments.\n   * @param {function(Dataflow)} callback - The callback function to run.\n   *   The callback will be invoked with this Dataflow instance as its\n   *   sole argument.\n   * @param {boolean} enqueue - A boolean flag indicating that the\n   *   callback should be queued up to run after the next propagation\n   *   cycle, suppressing immediate invocation when propagation is not\n   *   currently occurring.\n   * @param {number} [priority] - A priority value used to sort registered\n   *   callbacks to determine execution order. This argument is intended\n   *   for internal Vega use only.\n   */\n  function runAfter(callback, enqueue, priority) {\n    if (this._pulse || enqueue) {\n      // pulse propagation is currently running, queue to run after\n      this._postrun.push({\n        priority: priority || 0,\n        callback: callback\n      });\n    } else {\n      // pulse propagation already complete, invoke immediately\n      try { callback(this); } catch (err) { this.error(err); }\n    }\n  }\n\n  /**\n   * Raise an error for re-entrant dataflow evaluation.\n   */\n  function reentrant(df) {\n    df.error('Dataflow already running. Use runAsync() to chain invocations.');\n    return df;\n  }\n\n  /**\n   * Enqueue an operator into the priority queue for evaluation. The operator\n   * will be enqueued if it has no registered pulse for the current cycle, or if\n   * the force argument is true. Upon enqueue, this method also sets the\n   * operator's qrank to the current rank value.\n   * @param {Operator} op - The operator to enqueue.\n   * @param {boolean} [force] - A flag indicating if the operator should be\n   *   forceably added to the queue, even if it has already been previously\n   *   enqueued during the current pulse propagation. This is useful when the\n   *   dataflow graph is dynamically modified and the operator rank changes.\n   */\n  function enqueue(op, force) {\n    var q = op.stamp < this._clock;\n    if (q) op.stamp = this._clock;\n    if (q || force) {\n      op.qrank = op.rank;\n      this._heap.push(op);\n    }\n  }\n\n  /**\n   * Provide a correct pulse for evaluating an operator. If the operator has an\n   * explicit source operator, we will try to pull the pulse(s) from it.\n   * If there is an array of source operators, we build a multi-pulse.\n   * Otherwise, we return a current pulse with correct source data.\n   * If the pulse is the pulse map has an explicit target set, we use that.\n   * Else if the pulse on the upstream source operator is current, we use that.\n   * Else we use the pulse from the pulse map, but copy the source tuple array.\n   * @param {Operator} op - The operator for which to get an input pulse.\n   * @param {string} [encode] - An (optional) encoding set name with which to\n   *   annotate the returned pulse. See {@link run} for more information.\n   */\n  function getPulse(op, encode) {\n    var s = op.source,\n        stamp = this._clock;\n\n    return s && vegaUtil.isArray(s)\n      ? new MultiPulse(this, stamp, s.map(_ => _.pulse), encode)\n      : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);\n  }\n\n  function singlePulse(p, s) {\n    if (s && s.stamp === p.stamp) {\n      return s;\n    }\n\n    p = p.fork();\n    if (s && s !== StopPropagation) {\n      p.source = s.source;\n    }\n    return p;\n  }\n\n  var NO_OPT = {skip: false, force: false};\n\n  /**\n   * Touches an operator, scheduling it to be evaluated. If invoked outside of\n   * a pulse propagation, the operator will be evaluated the next time this\n   * dataflow is run. If invoked in the midst of pulse propagation, the operator\n   * will be queued for evaluation if and only if the operator has not yet been\n   * evaluated on the current propagation timestamp.\n   * @param {Operator} op - The operator to touch.\n   * @param {object} [options] - Additional options hash.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *   be skipped: it will not be evaluated, but its dependents will be.\n   * @return {Dataflow}\n   */\n  function touch(op, options) {\n    var opt = options || NO_OPT;\n    if (this._pulse) {\n      // if in midst of propagation, add to priority queue\n      this._enqueue(op);\n    } else {\n      // otherwise, queue for next propagation\n      this._touched.add(op);\n    }\n    if (opt.skip) op.skip(true);\n    return this;\n  }\n\n  /**\n   * Updates the value of the given operator.\n   * @param {Operator} op - The operator to update.\n   * @param {*} value - The value to set.\n   * @param {object} [options] - Additional options hash.\n   * @param {boolean} [options.force] - If true, the operator will\n   *   be re-evaluated even if its value has not changed.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *   be skipped: it will not be evaluated, but its dependents will be.\n   * @return {Dataflow}\n   */\n  function update(op, value, options) {\n    var opt = options || NO_OPT;\n    if (op.set(value) || opt.force) {\n      this.touch(op, opt);\n    }\n    return this;\n  }\n\n  /**\n   * Pulses an operator with a changeset of tuples. If invoked outside of\n   * a pulse propagation, the pulse will be applied the next time this\n   * dataflow is run. If invoked in the midst of pulse propagation, the pulse\n   * will be added to the set of active pulses and will be applied if and\n   * only if the target operator has not yet been evaluated on the current\n   * propagation timestamp.\n   * @param {Operator} op - The operator to pulse.\n   * @param {ChangeSet} value - The tuple changeset to apply.\n   * @param {object} [options] - Additional options hash.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *   be skipped: it will not be evaluated, but its dependents will be.\n   * @return {Dataflow}\n   */\n  function pulse(op, changeset, options) {\n    this.touch(op, options || NO_OPT);\n\n    var p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)),\n        t = op.pulse && op.pulse.source || [];\n\n    p.target = op;\n    this._input[op.id] = changeset.pulse(p, t);\n\n    return this;\n  }\n\n  function Heap(cmp) {\n    var nodes = [];\n    return {\n      clear: () => nodes = [],\n      size: () => nodes.length,\n      peek: () => nodes[0],\n      push: x => {\n        nodes.push(x);\n        return siftdown(nodes, 0, nodes.length - 1, cmp);\n      },\n      pop: () => {\n        var last = nodes.pop(), item;\n        if (nodes.length) {\n          item = nodes[0];\n          nodes[0] = last;\n          siftup(nodes, 0, cmp);\n        } else {\n          item = last;\n        }\n        return item;\n      }\n    };\n  }\n\n  function siftdown(array, start, idx, cmp) {\n    var item, parent, pidx;\n\n    item = array[idx];\n    while (idx > start) {\n      pidx = (idx - 1) >> 1;\n      parent = array[pidx];\n      if (cmp(item, parent) < 0) {\n        array[idx] = parent;\n        idx = pidx;\n        continue;\n      }\n      break;\n    }\n    return (array[idx] = item);\n  }\n\n  function siftup(array, idx, cmp) {\n    var start = idx,\n        end = array.length,\n        item = array[idx],\n        cidx = (idx << 1) + 1, ridx;\n\n    while (cidx < end) {\n      ridx = cidx + 1;\n      if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {\n        cidx = ridx;\n      }\n      array[idx] = array[cidx];\n      idx = cidx;\n      cidx = (idx << 1) + 1;\n    }\n    array[idx] = item;\n    return siftdown(array, start, idx, cmp);\n  }\n\n  /**\n   * A dataflow graph for reactive processing of data streams.\n   * @constructor\n   */\n  function Dataflow() {\n    this.logger(vegaUtil.logger());\n    this.logLevel(vegaUtil.Error);\n\n    this._clock = 0;\n    this._rank = 0;\n    try {\n      this._loader = vegaLoader.loader();\n    } catch (e) {\n      // do nothing if loader module is unavailable\n    }\n\n    this._touched = UniqueList(vegaUtil.id);\n    this._input = {};\n    this._pulse = null;\n\n    this._heap = Heap((a, b) => a.qrank - b.qrank);\n    this._postrun = [];\n  }\n\n  var prototype$5 = Dataflow.prototype;\n\n  /**\n   * The current timestamp of this dataflow. This value reflects the\n   * timestamp of the previous dataflow run. The dataflow is initialized\n   * with a stamp value of 0. The initial run of the dataflow will have\n   * a timestap of 1, and so on. This value will match the\n   * {@link Pulse.stamp} property.\n   * @return {number} - The current timestamp value.\n   */\n  prototype$5.stamp = function() {\n    return this._clock;\n  };\n\n  /**\n   * Gets or sets the loader instance to use for data file loading. A\n   * loader object must provide a \"load\" method for loading files and a\n   * \"sanitize\" method for checking URL/filename validity. Both methods\n   * should accept a URI and options hash as arguments, and return a Promise\n   * that resolves to the loaded file contents (load) or a hash containing\n   * sanitized URI data with the sanitized url assigned to the \"href\" property\n   * (sanitize).\n   * @param {object} _ - The loader instance to use.\n   * @return {object|Dataflow} - If no arguments are provided, returns\n   *   the current loader instance. Otherwise returns this Dataflow instance.\n   */\n  prototype$5.loader = function(_) {\n    if (arguments.length) {\n      this._loader = _;\n      return this;\n    } else {\n      return this._loader;\n    }\n  };\n\n  /**\n   * Empty entry threshold for garbage cleaning. Map data structures will\n   * perform cleaning once the number of empty entries exceeds this value.\n   */\n  prototype$5.cleanThreshold = 1e4;\n\n  // OPERATOR REGISTRATION\n  prototype$5.add = add;\n  prototype$5.connect = connect;\n  prototype$5.rank = rank;\n  prototype$5.rerank = rerank;\n\n  // OPERATOR UPDATES\n  prototype$5.pulse = pulse;\n  prototype$5.touch = touch;\n  prototype$5.update = update;\n  prototype$5.changeset = changeset;\n\n  // DATA LOADING\n  prototype$5.ingest = ingest$1;\n  prototype$5.parse  = parse;\n  prototype$5.preload = preload;\n  prototype$5.request = request;\n\n  // EVENT HANDLING\n  prototype$5.events = events;\n  prototype$5.on = on;\n\n  // PULSE PROPAGATION\n  prototype$5.evaluate = evaluate;\n  prototype$5.run = run;\n  prototype$5.runAsync = runAsync;\n  prototype$5.runAfter = runAfter;\n  prototype$5._enqueue = enqueue;\n  prototype$5._getPulse = getPulse;\n\n  // LOGGING AND ERROR HANDLING\n\n  function logMethod(method) {\n    return function() {\n      return this._log[method].apply(this, arguments);\n    };\n  }\n\n  /**\n   * Get or set the logger instance used to log messages. If no arguments are\n   * provided, returns the current logger instance. Otherwise, sets the logger\n   * and return this Dataflow instance. Provided loggers must support the full\n   * API of logger objects generated by the vega-util logger method. Note that\n   * by default the log level of the new logger will be used; use the logLevel\n   * method to adjust the log level as needed.\n   */\n  prototype$5.logger = function(logger) {\n    if (arguments.length) {\n      this._log = logger;\n      return this;\n    } else {\n      return this._log;\n    }\n  };\n\n  /**\n   * Logs an error message. By default, logged messages are written to console\n   * output. The message will only be logged if the current log level is high\n   * enough to permit error messages.\n   */\n  prototype$5.error = logMethod('error');\n\n  /**\n   * Logs a warning message. By default, logged messages are written to console\n   * output. The message will only be logged if the current log level is high\n   * enough to permit warning messages.\n   */\n  prototype$5.warn = logMethod('warn');\n\n  /**\n   * Logs a information message. By default, logged messages are written to\n   * console output. The message will only be logged if the current log level is\n   * high enough to permit information messages.\n   */\n  prototype$5.info = logMethod('info');\n\n  /**\n   * Logs a debug message. By default, logged messages are written to console\n   * output. The message will only be logged if the current log level is high\n   * enough to permit debug messages.\n   */\n  prototype$5.debug = logMethod('debug');\n\n  /**\n   * Get or set the current log level. If an argument is provided, it\n   * will be used as the new log level.\n   * @param {number} [level] - Should be one of None, Warn, Info\n   * @return {number} - The current log level.\n   */\n  prototype$5.logLevel = logMethod('level');\n\n  /**\n   * Abstract class for operators that process data tuples.\n   * Subclasses must provide a {@link transform} method for operator processing.\n   * @constructor\n   * @param {*} [init] - The initial value for this operator.\n   * @param {object} [params] - The parameters for this operator.\n   * @param {Operator} [source] - The operator from which to receive pulses.\n   */\n  function Transform(init, params) {\n    Operator.call(this, init, null, params);\n  }\n\n  var prototype$6 = vegaUtil.inherits(Transform, Operator);\n\n  /**\n   * Overrides {@link Operator.evaluate} for transform operators.\n   * Internally, this method calls {@link evaluate} to perform processing.\n   * If {@link evaluate} returns a falsy value, the input pulse is returned.\n   * This method should NOT be overridden, instead overrride {@link evaluate}.\n   * @param {Pulse} pulse - the current dataflow pulse.\n   * @return the output pulse for this operator (or StopPropagation)\n   */\n  prototype$6.run = function(pulse) {\n    if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n\n    var rv;\n    if (this.skip()) {\n      this.skip(false);\n    } else {\n      rv = this.evaluate(pulse);\n    }\n    rv = rv || pulse;\n\n    if (rv.then) {\n      rv = rv.then(_ => this.pulse =_);\n    } else if (rv !== pulse.StopPropagation) {\n      this.pulse = rv;\n    }\n\n    return rv;\n  };\n\n  /**\n   * Overrides {@link Operator.evaluate} for transform operators.\n   * Marshalls parameter values and then invokes {@link transform}.\n   * @param {Pulse} pulse - the current dataflow pulse.\n   * @return {Pulse} The output pulse (or StopPropagation). A falsy return\n       value (including undefined) will let the input pulse pass through.\n   */\n  prototype$6.evaluate = function(pulse) {\n    var params = this.marshall(pulse.stamp),\n        out = this.transform(params, pulse);\n    params.clear();\n    return out;\n  };\n\n  /**\n   * Process incoming pulses.\n   * Subclasses should override this method to implement transforms.\n   * @param {Parameters} _ - The operator parameter values.\n   * @param {Pulse} pulse - The current dataflow pulse.\n   * @return {Pulse} The output pulse (or StopPropagation). A falsy return\n   *   value (including undefined) will let the input pulse pass through.\n   */\n  prototype$6.transform = function() {};\n\n  var transforms = {};\n\n  function definition(type) {\n    var t = transform(type);\n    return t && t.Definition || null;\n  }\n\n  function transform(type) {\n    type = type && type.toLowerCase();\n    return vegaUtil.hasOwnProperty(transforms, type) ? transforms[type] : null;\n  }\n\n  exports.Dataflow = Dataflow;\n  exports.EventStream = EventStream;\n  exports.MultiPulse = MultiPulse;\n  exports.Operator = Operator;\n  exports.Parameters = Parameters;\n  exports.Pulse = Pulse;\n  exports.Transform = Transform;\n  exports.UniqueList = UniqueList;\n  exports.asyncCallback = asyncCallback;\n  exports.changeset = changeset;\n  exports.definition = definition;\n  exports.derive = derive;\n  exports.ingest = ingest;\n  exports.isChangeSet = isChangeSet;\n  exports.isTuple = isTuple;\n  exports.rederive = rederive;\n  exports.replace = replace;\n  exports.stableCompare = stableCompare;\n  exports.transform = transform;\n  exports.transforms = transforms;\n  exports.tupleid = tupleid;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","factory","define","amd","self","vega","vegaUtil","vegaLoader","UniqueList","idFunc","$","identity","list","ids","add","list.add","_","id","push","remove","list.remove","idx","indexOf","splice","asyncCallback","df","callback","err","error","ingest","datum","t","Object","data","TUPLE_ID_KEY","rederive","d","k","isChangeSet","v","constructor","changeset","rem","mod","remp","modp","reflow","insert","array","i","n","length","a","isFunction","modify","field","value","m","constant","filter","tuple","encode","set","pulse","tuples","f","out","cur","forEach","modifies","slice","Parameters","defineProperty","CACHE","writable","Operator","init","update","params","react","OP_ID","qrank","rank","stamp","flags","_update","parameters","flag","bit","state","arguments","EventStream","apply","receive","STREAM_ID","_filter","_apply","stream","loadPending","pending","Promise","accept","requests","done","pending.done","_pending","onStream","target","options","opt","extend","SKIP$1","undefined","func","e","touch","op","evaluate","onOperator","source","targets","updater","modified","force","skip","connect","Pulse","dataflow","fields","addFilter","b","materialize","visitArray","map","visit","MultiPulse","pulses","c","hash","p","changed","ADD","REM","MOD","changes","reentrant","singlePulse","s","fork","StopPropagation","Heap","cmp","nodes","clear","size","peek","x","siftdown","pop","last","item","start","end","cidx","ridx","pidx","parent","Dataflow","logger","logLevel","Error","_rank","_clock","_loader","loader","_touched","_input","_pulse","_heap","_postrun","logMethod","method","_log","Transform","call","transform","type","toLowerCase","hasOwnProperty","transforms","Symbol","TUPLE_ID","prototype","prototype.set","name","index","o","isArray","prototype.modified","prototype.clear","NO_PARAMS","prototype$1","prototype$1.targets","_targets","prototype$1.set","SKIP","MODIFIED","prototype$1.parameters","initonly","deps","argops","argval","_argval","_argops","PULSE","Array","marshall","prototype$1.marshall","prototype$1.evaluate","run","prototype$1.run","rv","prototype$2","truthy","prototype$2.targets","consume","prototype$2.consume","_consume","prototype$2.receive","evt","val","trg","preventDefault","stopPropagation","prototype$2.filter","prototype$2.apply","merge","prototype$2.merge","throttle","prototype$2.throttle","pause","now","Date","debounce","prototype$2.debounce","delay","between","prototype$2.between","active","parse","read","prototype$3","ADD_REM","ADD_MOD","ALL","REFLOW","SOURCE","NO_SOURCE","NO_FIELDS","prototype$3.fork","clone","prototype$3.clone","addAll","prototype$3.addAll","prototype$3.init","src","addF","remF","modF","srcF","runAfter","prototype$3.runAfter","prototype$3.changed","prototype$3.reflow","len","prototype$3.modifies","prototype$3.modified","nomod","some","prototype$3.filter","prototype$3.materialize","prototype$3.visit","visitor","sum","prototype$4","inherits","prototype$4.fork","prototype$4.changed","prototype$4.modified","prototype$4.filter","prototype$4.materialize","prototype$4.visit","NO_OPT","prototype$5","prototype$5.stamp","prototype$5.loader","cleanThreshold","shift","sources","targetRank","rerank","queue","_enqueue","ingest$1","format","preload","url","res","request","status","load","context","response","responseType","warn","events","send","document","querySelectorAll","addEventListener","on","fn","prerun","postrun","level","count","next","dt","pr","info","Info","debug","_getPulse","then","Debug","sort","priority","runAsync","_running","enqueue","q","getPulse","prototype$5.logger","prototype$6","prototype$6.run","prototype$6.evaluate","prototype$6.transform","definition","Definition","derive","isTuple","replace","stableCompare","tupleid"]
}
