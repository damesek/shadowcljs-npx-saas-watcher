shadow$provide.module$node_modules$vega_runtime$build$vega_runtime=function(global$jscomp$0,process,require,module,exports$jscomp$0,shadow$shims){(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module?factory(exports$jscomp$0,require("module$node_modules$vega_dataflow$build$vega_dataflow"),require("module$node_modules$vega_util$build$vega_util")):"function"===typeof define&&define.amd?define(["exports","vega-dataflow","vega-util"],factory):(global=global||self,factory(global.vega=
{},global.vega,global.vega))})(this,function(exports,vegaDataflow,vegaUtil){function expression(args,code,ctx){";"!==code[code.length-1]&&(code="return("+code+");");args=Function.apply(null,args.concat(code));return ctx&&ctx.functions?args.bind(ctx.functions):args}function parseParameters(spec,ctx,params){params=params||{};var key;for(key in spec){var value=spec[key];params[key]=vegaUtil.isArray(value)?value.map(function(v){return parseParameter(v,ctx,params)}):parseParameter(value,ctx,params)}return params}
function parseParameter(spec,ctx,params){if(!spec||!vegaUtil.isObject(spec))return spec;for(var i=0,n=PARSERS.length,p;i<n;++i)if(p=PARSERS[i],vegaUtil.hasOwnProperty(spec,p.key))return p.parse(spec,ctx,params);return spec}function parseDataflow(spec,ctx){var operators=spec.operators||[];spec.background&&(ctx.background=spec.background);spec.eventConfig&&(ctx.eventConfig=spec.eventConfig);operators.forEach(function(entry){"operator"!==(entry.type+"").toLowerCase()&&entry.type?ctx.transform(entry,
entry.type):ctx.operator(entry,entry.update?expression(["_"],entry.update,ctx):null)});operators.forEach(function(entry){if(entry.params){var op=ctx.get(entry.id);op||vegaUtil.error("Invalid operator id: "+entry.id);ctx.dataflow.connect(op,op.parameters(parseParameters(entry.params,ctx),entry.react,entry.initonly))}});(spec.streams||[]).forEach(function(entry){var filter=null!=entry.filter?expression(["event"],entry.filter,ctx):void 0,stream=null!=entry.stream?ctx.get(entry.stream):void 0;if(entry.source)stream=
ctx.events(entry.source,entry.type,filter);else if(entry.merge){var args=entry.merge.map(ctx.get.bind(ctx));stream=args[0].merge.apply(args[0],args.slice(1))}entry.between&&(args=entry.between.map(ctx.get.bind(ctx)),stream=stream.between(args[0],args[1]));entry.filter&&(stream=stream.filter(filter));null!=entry.throttle&&(stream=stream.throttle(+entry.throttle));null!=entry.debounce&&(stream=stream.debounce(+entry.debounce));null==stream&&vegaUtil.error("Invalid stream definition: "+JSON.stringify(entry));
entry.consume&&stream.consume(!0);ctx.stream(entry,stream)});(spec.updates||[]).forEach(function(entry){var srcid=vegaUtil.isObject(srcid=entry.source)?srcid.$ref:srcid;srcid=ctx.get(srcid);var update=entry.update,params=void 0;srcid||vegaUtil.error("Source not defined: "+entry.source);var target=entry.target&&entry.target.$expr?expression(["event"],entry.target.$expr,ctx):ctx.get(entry.target);update&&update.$expr&&(update.$params&&(params=parseParameters(update.$params,ctx)),update=expression(["_",
"event"],update.$expr,ctx));ctx.update(entry,srcid,target,update,params)});return ctx.resolve()}function Context(df,transforms,functions){this.dataflow=df;this.transforms=transforms;this.events=df.events.bind(df);this.signals={};this.scales={};this.nodes={};this.data={};this.fn={};functions&&(this.functions=Object.create(functions),this.functions.context=this)}function ContextFork(ctx){this.dataflow=ctx.dataflow;this.transforms=ctx.transforms;this.functions=ctx.functions;this.events=ctx.events;this.signals=
Object.create(ctx.signals);this.scales=Object.create(ctx.scales);this.nodes=Object.create(ctx.nodes);this.data=Object.create(ctx.data);this.fn=Object.create(ctx.fn);ctx.functions&&(this.functions=Object.create(ctx.functions),this.functions.context=this)}var PARSERS=[{key:"$ref",parse:function(_,ctx){return ctx.get(_.$ref)||vegaUtil.error("Operator not defined: "+_.$ref)}},{key:"$key",parse:function(_,ctx){var k="k:"+_.$key+"_"+!!_.$flat;return ctx.fn[k]||(ctx.fn[k]=vegaUtil.key(_.$key,_.$flat))}},
{key:"$expr",parse:function(_,ctx,params){_.$params&&parseParameters(_.$params,ctx,params);params="e:"+_.$expr+"_"+_.$name;return ctx.fn[params]||(ctx.fn[params]=vegaUtil.accessor(expression(["datum","_"],_.$expr,ctx),_.$fields,_.$name))}},{key:"$field",parse:function(_,ctx){if(!_.$field)return null;var k="f:"+_.$field+"_"+_.$name;return ctx.fn[k]||(ctx.fn[k]=vegaUtil.field(_.$field,_.$name))}},{key:"$encode",parse:function(_,ctx){_=_.$encode;var encode={},name;for(name in _){var enc=_[name];encode[name]=
vegaUtil.accessor(expression(["item","_"],enc.$expr,ctx),enc.$fields);encode[name].output=enc.$output}return encode}},{key:"$compare",parse:function(_$jscomp$0,ctx){var k="c:"+_$jscomp$0.$compare+"_"+_$jscomp$0.$order,c=vegaUtil.array(_$jscomp$0.$compare).map(function(_){return _&&_.$tupleid?vegaDataflow.tupleid:_});return ctx.fn[k]||(ctx.fn[k]=vegaUtil.compare(c,_$jscomp$0.$order))}},{key:"$context",parse:function(_,ctx){return ctx}},{key:"$subflow",parse:function(_,ctx){var spec=_.$subflow;return function(dataflow,
key,parent){key=parseDataflow(spec,ctx.fork());dataflow=key.get(spec.operators[0].id);(key=key.signals.parent)&&key.set(parent);return dataflow}}},{key:"$tupleid",parse:function(){return vegaDataflow.tupleid}}],SKIP={skip:!0};Context.prototype=ContextFork.prototype={fork:function(){var ctx=new ContextFork(this);(this.subcontext||(this.subcontext=[])).push(ctx);return ctx},get:function(id){return this.nodes[id]},set:function(id,node){return this.nodes[id]=node},add:function(spec,op){var ctx=this,df=
ctx.dataflow,data;ctx.set(spec.id,op);"collect"===(spec.type+"").toLowerCase()&&(data=spec.value)&&(data.$ingest?df.ingest(op,data.$ingest,data.$format):data.$request?df.preload(op,data.$request,data.$format):df.pulse(op,df.changeset().insert(data)));spec.root&&(ctx.root=op);if(spec.parent){var p=ctx.get(spec.parent.$ref);p?(df.connect(p,[op]),op.targets().add(p)):(ctx.unresolved=ctx.unresolved||[]).push(function(){p=ctx.get(spec.parent.$ref);df.connect(p,[op]);op.targets().add(p)})}spec.signal&&
(ctx.signals[spec.signal]=op);spec.scale&&(ctx.scales[spec.scale]=op);if(spec.data)for(var name in spec.data)data=ctx.data[name]||(ctx.data[name]={}),spec.data[name].forEach(function(role){data[role]=op})},resolve:function(){(this.unresolved||[]).forEach(function(fn){fn()});delete this.unresolved;return this},operator:function(spec,update){this.add(spec,this.dataflow.add(spec.value,update))},transform:function(spec,type){this.add(spec,this.dataflow.add(this.transforms[(type+"").toLowerCase()]))},
stream:function(spec,stream){this.set(spec.id,stream)},update:function(spec,stream,target,update,params){this.dataflow.on(stream,target,update,params,spec.options)},getState:function(options){var ctx$jscomp$0=this,state={};if(options.signals){var signals=state.signals={};Object.keys(ctx$jscomp$0.signals).forEach(function(key){var op=ctx$jscomp$0.signals[key];options.signals(key,op)&&(signals[key]=op.value)})}if(options.data){var data=state.data={};Object.keys(ctx$jscomp$0.data).forEach(function(key){var dataset=
ctx$jscomp$0.data[key];options.data(key,dataset)&&(data[key]=dataset.input.value)})}ctx$jscomp$0.subcontext&&!1!==options.recurse&&(state.subcontext=ctx$jscomp$0.subcontext.map(function(ctx){return ctx.getState(options)}));return state},setState:function(state){var ctx=this,df=ctx.dataflow,data=state.data,signals=state.signals;Object.keys(signals||{}).forEach(function(key){df.update(ctx.signals[key],signals[key],SKIP)});Object.keys(data||{}).forEach(function(key){df.pulse(ctx.data[key].input,df.changeset().remove(vegaUtil.truthy).insert(data[key]))});
(state.subcontext||[]).forEach(function(substate,i){(i=ctx.subcontext[i])&&i.setState(substate)})}};exports.context=function(df,transforms,functions){return new Context(df,transforms,functions)};exports.expression=expression;exports.parse=parseDataflow;Object.defineProperty(exports,"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$vega_runtime$build$vega_runtime.js.map
